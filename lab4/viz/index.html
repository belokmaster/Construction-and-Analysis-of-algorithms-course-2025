<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>KMP Algorithm Visualization</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .controls { margin-bottom: 20px; }
        canvas { border: 1px solid #ccc; }
        #status { margin-top: 10px; }
        #speed-label { margin-left: 10px; }
        .step-controls { margin-top: 10px; }
        #prefix-container { margin-top: 20px; border: 1px solid #ccc; padding: 10px; }
        #prefix-label {
            font-weight: bold;
            margin-bottom: 30px; /* добавили отступ вниз */
        }
        #prefix-function-container { display: flex; align-items: center; }
        .prefix-box {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: monospace;
            font-size: 14px;
            margin-right: 5px;
            position: relative;
            background-color: #f9f9f9;
        }
        .prefix-index {
            position: absolute;
            top: -20px;
            font-size: 15px;
            color: #555;
        }
        #answer-container { margin-top: 20px; border: 1px solid #ccc; padding: 10px; }
        #answer-label { font-weight: bold; margin-bottom: 5px; }
        #answer { font-family: monospace; }
        .text-index {
            position: absolute;
            bottom: -100px;
            font-size: 15px;
            color: #555;
            width: 30px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>KMP Algorithm Visualization</h1>
    <div class="controls">
        <label for="text">Text:</label>
        <input type="text" id="text" value="aababcabcdabcdeabcdef"><br><br>
        <label for="pattern">Pattern:</label>
        <input type="text" id="pattern" value="abcdef"><br><br>
        <label for="speed">Animation Speed:</label>
        <input type="range" id="speed" min="50" max="3000" value="500" step="100">
        <span id="speed-label">500 ms</span><br><br>
        <button onclick="startAnimation()">Start Animation</button>
        <button onclick="pauseAnimation()">Pause</button>
        <button onclick="reset()">Reset</button>
        <div class="step-controls">
            <button onclick="prevStep()">Previous Step</button>
            <button onclick="nextStep()">Next Step</button>
            <span id="step-counter">Step: 0/0</span>
        </div>
    </div>
    <canvas id="canvas" width="800" height="220"></canvas>
    <div id="status"></div>

    <div id="prefix-container">
        <div id="prefix-label">Префикс-функция:</div>
        <div id="prefix-function-container"></div>
    </div>

    <div id="answer-container">
        <div id="answer-label">Found at indices:</div>
        <div id="answer"></div>
    </div>

    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const BOX_WIDTH = 30;
        const BOX_HEIGHT = 30;
        const MARGIN_X = 40;
        const MARGIN_Y = 40;
        const ROW_SPACING = 20;
        let steps = [];
        let currentStep = 0;
        let text = "";
        let pattern = "";
        let animationId = null;
        let isAnimating = false;

        // Установка более высокого разрешения для canvas
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = `${rect.width}px`;    // ← добавь это
        canvas.style.height = `${rect.height}px`;  // ← и это
        ctx.scale(dpr, dpr);

        // Обновление метки скорости
        const speedInput = document.getElementById("speed");
        const speedLabel = document.getElementById("speed-label");
        speedInput.addEventListener("input", () => {
            speedLabel.textContent = `${speedInput.value} ms`;
        });

        function updateStepCounter() {
            document.getElementById("step-counter").textContent = `Step: ${currentStep + 1}/${steps.length}`;
        }

        function drawCharBox(x, y, value, isMismatch) {
            ctx.fillStyle = isMismatch ? "#ffcccc" : "#ffffff"; // Красный фон при несовпадении
            ctx.strokeStyle = "#000";
            ctx.fillRect(x, y, BOX_WIDTH, BOX_HEIGHT);
            ctx.strokeRect(x, y, BOX_WIDTH, BOX_HEIGHT); // Черная граница

            // Если есть несовпадение, рисуем красную границу поверх черной
            if (isMismatch) {
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#f00"; // Красная граница
                // Рисуем красную границу с одинаковой толщиной
                ctx.strokeRect(x - 1, y - 1, BOX_WIDTH + 2, BOX_HEIGHT + 2); // Увеличиваем размер для красной границы
                ctx.lineWidth = 1;
            }

            // Рисуем символ
            ctx.fillStyle = "#000";
            ctx.font = "16px Monospace";
            ctx.textAlign = "center";
            ctx.fillText(value, x + BOX_WIDTH / 2, y + BOX_HEIGHT / 2 + 5);
            ctx.textAlign = "left"; // Возвращаем выравнивание по левому краю
        }

        function drawTextAndPattern(stepIndex) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = "16px Monospace";
            ctx.textAlign = "left";

            if (steps.length === 0 || stepIndex < 0 || stepIndex >= steps.length) return;

            const step = steps[stepIndex];
            const textIndex = step.textIndex;
            const patternIndex = step.patternIndex;
            const shift = textIndex - patternIndex;

            // Отрисовка текста
            for (let i = 0; i < text.length; i++) {
                const x = MARGIN_X + i * BOX_WIDTH;
                const y = MARGIN_Y;
                const isCurrent = i === textIndex;
                const isMismatch = isCurrent && patternIndex >= 0 &&
                                    text[textIndex] !== pattern[patternIndex];
                drawCharBox(x, y, text[i], isMismatch);

                // Подсветка текущего символа
                if (isCurrent) {
                    ctx.strokeStyle = "#f00";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, BOX_WIDTH, BOX_HEIGHT);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = "#000";
                }

                // Отрисовка индексов под текстом
                ctx.fillStyle = "#555";
                ctx.font = "15px Monospace";
                ctx.textAlign = "center";
                ctx.fillText(i, x + BOX_WIDTH / 2, MARGIN_Y + BOX_HEIGHT + 20);
                ctx.textAlign = "left";
            }

            // Отрисовка подстроки с учетом сдвига
            for (let i = 0; i < pattern.length; i++) {
                const x = MARGIN_X + (i + shift) * BOX_WIDTH;
                const y = MARGIN_Y + BOX_HEIGHT + ROW_SPACING + 30;
                const isCurrent = i === patternIndex;
                const isMismatch = isCurrent && patternIndex >= 0 &&
                                    text[textIndex] !== pattern[patternIndex];
                drawCharBox(x, y, pattern[i], isMismatch);

                // Подсветка текущего символа
                if (isCurrent) {
                    ctx.strokeStyle = "#f00";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, BOX_WIDTH, BOX_HEIGHT);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = "#000";
                }
            }

            // Обновление статуса
            document.getElementById("status").textContent =
                `Шаг ${stepIndex + 1}: ${step.status} (Сравнений: ${step.comparisons})`;

            // Обновление массива префикс-функции
            const prefixContainer = document.getElementById("prefix-function-container");
            prefixContainer.innerHTML = ""; // Очищаем предыдущие элементы
            if (step.prefixFunction) {
                step.prefixFunction.forEach((value, index) => {
                    const box = document.createElement("div");
                    box.classList.add("prefix-box");
                    box.textContent = value;

                    // Добавляем подсветку, если индекс совпадает с highlightPrefixIndex
                    if (step.highlightPrefixIndex !== undefined && step.highlightPrefixIndex === index) {
                        box.style.backgroundColor = "#ffeb3b"; // ярко-жёлтый фон
                        box.style.border = "2px solid #f00";   // красная рамка
                    } else {
                        box.style.backgroundColor = "#f9f9f9"; // Возвращаем стандартный фон
                        box.style.border = "1px solid #ccc";   // Возвращаем стандартную рамку
                    }

                    const indexLabel = document.createElement("div");
                    indexLabel.classList.add("prefix-index");
                    indexLabel.textContent = index;
                    box.appendChild(indexLabel);
                    prefixContainer.appendChild(box);
                });
            }

            updateStepCounter();
        }

        function animate() {
            if (currentStep >= steps.length) {
                pauseAnimation();
                document.getElementById("status").textContent += "\nАнимация завершена.";
                return;
            }

            drawTextAndPattern(currentStep);

            if (isAnimating) {
                currentStep++;
                const delay = parseInt(speedInput.value);
                setTimeout(() => {
                    if (currentStep < steps.length) {
                        animationId = requestAnimationFrame(animate);
                    }
                }, delay);
            }
        }

        function startAnimation() {
            // Если шаги еще не загружены или анимация завершена
            if (steps.length === 0 || currentStep >= steps.length) {
                const textInput = document.getElementById("text").value;
                const patternInput = document.getElementById("pattern").value;

                fetch('/kmp', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: textInput, pattern: patternInput })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        document.getElementById("status").textContent = `Ошибка: ${data.error}`;
                        return;
                    }

                    text = textInput;
                    pattern = patternInput;
                    steps = data.steps;
                    currentStep = 0;
                    isAnimating = true;
                    if (animationId) cancelAnimationFrame(animationId);
                    animate();
                    document.getElementById("answer").textContent = data.positions.join(", ");
                })
                .catch(err => {
                    console.error(err);
                    document.getElementById("status").textContent = "Произошла ошибка.";
                });
            } else {
                // Продолжаем анимацию с текущего шага
                isAnimating = true;
                if (animationId) cancelAnimationFrame(animationId);
                animate();
            }
        }

        function pauseAnimation() {
            isAnimating = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function prevStep() {
            pauseAnimation();
            if (currentStep > 0) {
                currentStep--;
                drawTextAndPattern(currentStep);
            }
        }

        function nextStep() {
            pauseAnimation();
            if (currentStep < steps.length - 1) {
                currentStep++;
                drawTextAndPattern(currentStep);
            }
        }

        function reset() {
            document.getElementById("text").value = "aababcabcdabcdeabcdef";
            document.getElementById("pattern").value = "abcdef";
            document.getElementById("speed").value = "500";
            speedLabel.textContent = "500 ms";
            document.getElementById("status").textContent = "";
            document.getElementById("answer").textContent = "";
            document.getElementById("prefix-function-container").innerHTML = "";
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            pauseAnimation();
            steps = [];
            currentStep = 0;
            updateStepCounter();
        }
    </script>
</body>
</html>